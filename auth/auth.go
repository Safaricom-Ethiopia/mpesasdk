// Package auth provides functionalities to handle authorization tokens for M-Pesa API interactions.
// This package includes the generation, validation, and retrieval of tokens required for authenticated API requests.
package auth

import (
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"net/http"
	"strconv"
	"time"

	"github.com/coleYab/mpesasdk/common"
	"github.com/coleYab/mpesasdk/service"
	"github.com/coleYab/mpesasdk/utils"
)

// AuthorizationToken manages the authentication token used for M-Pesa API requests.
// It stores the token, its creation time, expiry duration, and the associated consumer key and secret.
type AuthorizationToken struct {
	token         string    // Bearer token for authorization
	createdAt     time.Time // Timestamp of token creation
	expiresIn     int       // Token expiry duration in seconds
	consumerKey   string    // API consumer key
	consumerSecret string   // API consumer secret
}

// Constants representing authentication types.
const (
	AuthTypeBearer = "Bearer" // Bearer token authentication type
	AuthTypeNone   = ""       // No authentication
	AuthTypeBasic  = "Basic"  // Basic authentication type
)

// NewAuthorizationToken creates a new instance of AuthorizationToken.
//
// Parameters:
//   - key: The API consumer key.
//   - secret: The API consumer secret.
//
// Returns:
//   - A pointer to an initialized AuthorizationToken instance.
func NewAuthorizationToken(key, secret string) *AuthorizationToken {
	return &AuthorizationToken{
		consumerKey:   key,
		consumerSecret: secret,
	}
}

// setAuthToken sets the authorization token along with its metadata.
//
// Parameters:
//   - tokenType: The type of the token (e.g., "Bearer").
//   - token: The authorization token.
//   - expiresIn: The token's expiry duration in seconds.
//   - key: The API consumer key.
//   - secret: The API consumer secret.
func (a *AuthorizationToken) setAuthToken(tokenType, token string, expiresIn int, key, secret string) {
	a.token = fmt.Sprintf("%v %v", tokenType, token)
	a.createdAt = time.Now()
	a.expiresIn = expiresIn
	a.consumerKey = key
	a.consumerSecret = secret
}

// GetConsumerKeyAndSecret retrieves the consumer key and secret associated with the token.
//
// Returns:
//   - consumerKey: The API consumer key.
//   - consumerSecret: The API consumer secret.
func (a *AuthorizationToken) GetConsumerKeyAndSecret() (string, string) {
	return a.consumerKey, a.consumerSecret
}

// GetAuthorizationToken retrieves the current valid authorization token, or generates a new one if expired.
//
// Parameters:
//   - env: The environment (e.g., PRODUCTION or SANDBOX) to determine the base URL.
//   - key: The API consumer key.
//   - secret: The API consumer secret.
//
// Returns:
//   - The valid authorization token.
//   - An error if the token cannot be generated or retrieved.
//
// Behavior:
//   - If the token is valid and not expired (within 2 seconds before expiry), it is returned.
//   - If expired or not set, a new token is generated by making a request to the M-Pesa API token endpoint.
//   - The token is then stored with its metadata for future use.
//
// Example:
//   token, err := authToken.GetAuthorizationToken(common.SANDBOX, "consumerKey", "consumerSecret")
//   if err != nil {
//       log.Fatalf("Failed to get token: %v", err)
//   }
//   fmt.Println("Authorization Token:", token)
func (a *AuthorizationToken) GetAuthorizationToken(env common.Enviroment, key, secret string) (string, error) {
	url := utils.ConstructURL(env, "/v1/token/generate?grant_type=client_credentials")
	method := "GET"

	// If token is still valid (2 seconds before expiry), return it
	if a.token != "" && time.Now().Before(a.createdAt.Add(time.Duration(a.expiresIn-2)*time.Second)) {
		return a.token, nil
	}

	// Otherwise, request a new token
	req, err := http.NewRequest(method, url, nil)
	if err != nil {
		return "", errors.New("error: while creating auth request")
	}

	req.Header.Add("Content-Type", "application/json")
	req.SetBasicAuth(key, secret)

	client := &http.Client{}
	res, err := client.Do(req)
	if err != nil {
		return "", err
	}

	body, err := io.ReadAll(res.Body)
	if err != nil {
		return "", err
	}
	defer res.Body.Close()

	var authResponse struct {
		AccessToken string `json:"access_token"`
		TokenType   string `json:"token_type"`
		ExpiresIn   string `json:"expires_in"`
		ResultCode  string `json:"resultCode"`
		ResultDesc  string `json:"resultDesc"`
	}

	err = json.Unmarshal(body, &authResponse)
	if err != nil {
		return "", err
	}

	// Handle errors from the response
	if authResponse.ResultCode != "" {
		return "", errors.New(authResponse.ResultDesc)
	}

	expiresIn, _ := strconv.Atoi(authResponse.ExpiresIn)
	a.setAuthToken(authResponse.TokenType, authResponse.AccessToken, expiresIn, key, secret)

	return a.token, nil
}

